use_mit_license("Andrew DiLernia")
update.packages('devtools')
library(devtools)
use_mit_license("Andrew DiLernia")
document()
document()
document()
document()
document()
document()
usethis::use_rcpp()
?rnorm
?var.sim
?ar.sim
?arsim
?tsDyn::VAR.sim
install.packages('tsDyn')
?tsDyn::VAR.sim
0.20^outer(1:50, 1:50)
0.20^outer(1:50, 1:50, "-")
0.20^abs(outer(1:50, 1:50, "-"))
varSim <- function(nt, coeffMat, covMat) {
# First generating errors for all variables for all t
wts <- MASS::mvrnorm(n = nt, mu = rep(0, ncol(covMat)), Sigma = covMat)
# Generating y values sequentially
ys <- matrix(0, nrow = nt, ncol = ncol(covMat))
ys[1, ] <- wts[1, ]
for(r in 2:nt) {
ys[r, ] <- t(coeffMat %*% ys[r-1, ]) + wts[r, ]
}
return(ys)
}
myData <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
matplot(myData)
matplot(myData, type = 'l')
matplot(myData, type = 'l', lty = "solid")
matplot(myData, type = 'l', lty = "solid", main = "Generated Multivariate Time Series")
matplot(myData, type = 'l', lty = "solid", main = "Generated Multivariate Time Series", xlab = "Time")
matplot(myData, type = 'l', lty = "solid", main = "Generated Multivariate Time Series", xlab = "Time", ylab = "value")
matplot(myData, type = 'l', lty = "solid", main = "Generated Multivariate Time Series", xlab = "Time", ylab = "Value")
document()
devtools::document()
?np::b.star
devtools::document()
devtools::document()
usethis::use_rcpp()
usethis::use_rcpp()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
pkgbuild::compile_dll()
devtools::document()
devtools::document()
pkgbuild::compile_dll()
devtools::document()
devtools::document()
?pcCov::bootVar
devtools::document()
?pcCov::bootVar
devtools::document()
?pcCov::bootVar
devtools::document()
?pcCov::bootVar
?pcCov::timesTwo
devtools::load_all(".")
?pcCov::timesTwo
pcCov::timesTwo
devtools::document()
?pcCov::timesTwo
devtools::load_all(".")
devtools::document()
?pcCov::timesTwo
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
?pcCov::timesTwo
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
?pcCov::eigen2arma
devtools::load_all(".")
devtools::document()
?pcCov::eigen2arma
devtools::load_all(".")
devtools::document()
?pcCov::eigen2arma
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
RcppArmadillo.package.skeleton()
RcppArmadillo::RcppArmadillo.package.skeleton()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
getwd()
RcppArmadillo.package.skeleton("C:/Users/Owner/Dropbox/Minnesota/testPackage")
RcppArmadillo::RcppArmadillo.package.skeleton("C:/Users/Owner/Dropbox/Minnesota/testPackage")
RcppArmadillo::RcppArmadillo.package.skeleton("C:/Users/Owner/Dropbox/Minnesota/testPackage")
?RcppArmadillo::RcppArmadillo.package.skeleton
RcppArmadillo::RcppArmadillo.package.skeleton(name = "myPackage", example_code = T, path = "C:/Users/Owner/Dropbox/Minnesota/testPackage")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::document()
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
?pcCov::partialCov_cpp
devtools::load_all(".")
devtools::document()
?pcCov::partialCov_cpp
library(pcCov)
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
myTS <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
# Asymptotic covariance matrix for partial correlations
p <- ncol(myTS)
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
?pcCov::royVar
devtools::document()
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
myTS <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
# Asymptotic covariance matrix for partial correlations
p <- ncol(myTS)
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
royVar(myTS)
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
?pcCov::royVar
devtools::document()
?pcCov::royVar
devtools::document()
?pcCov::royVar
?pcCov::bootVar
devtools::load_all(".")
devtools::document()
?pcCov::bootVar
devtools::load_all(".")
?pcCov::partialCov_cpp
devtools::load_all(".")
devtools::document()
?pcCov::partialCov_cpp
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
myTS <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
# Asymptotic covariance matrix for partial correlations
p <- ncol(myTS)
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
royVar(myTS)
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
?pcCov::partialCov_cpp
devtools::load_all(".")
devtools::document()
?pcCov::partialCov_cpp
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
myTS <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
# Asymptotic covariance matrix for partial correlations
p <- ncol(myTS)
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
microbenchmark::microbenchmark(partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2)), royVar(ts = myTS))
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994); p <- 5
myTS <- varSim(nt = 50, coeffMat = diag(0.50, p), covMat = diag(1, p))
# Asymptotic covariance matrix for partial correlations
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994); p <- 10
myTS <- varSim(nt = 50, coeffMat = diag(0.50, p), covMat = diag(1, p))
# Asymptotic covariance matrix for partial correlations
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
microbenchmark::microbenchmark(partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2)), royVar(ts = myTS), times = 50)
microbenchmark::microbenchmark(partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2)), royVar(ts = myTS, bw = 5), times = 10)
devtools::document()
devtools::document()
devtools::check()
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
library(pcCov)
pcCov::partialCov_cpp()
pcCov::partialCov_cpp
Rcpp::compileAttributes()
library(pcCov)
library(pcCov)
library(pcCov)
Rcpp::compileAttributes()
library(pcCov)
devtools::document()
remove.packages('pcCov')
RcppArmadillo::RcppArmadilloLibs()
RcppArmadillo::RcppArmadilloLibs()
RcppArmadillo::RcppArmadillo.package.skeleton()
?smooth.spline
require(graphics)
plot(dist ~ speed, data = cars, main = "data(cars)  &  smoothing splines")
cars.spl <- with(cars, smooth.spline(speed, dist))
cars.spl
## This example has duplicate points, so avoid cv = TRUE
myFit <- cars.spl$fit
residuals(myFit)
fitted.values(myFit)
predict(myFit)
predict(myFit)$x
predict(myFit)$y - cars$speed
residuals(cars.spl)
mean(residuals(cars.spl))
sp <- read.csv("http://www.stat.cmu.edu/~cshalizi/uADA/12/SPhistory.short.csv")
# We only want closing prices
sp <- sp[,7]
# The data are in reverse chronological order, which is weird for us
sp <- rev(sp)
# And in fact we only want log returns, i.e., difference in logged prices
sp <- diff(log(sp))
sp.spline <- smooth.spline(x=sp.today,y=sp.tomorrow,cv=TRUE)
sp.tomorrow <- sp[-1]
sp.today <- sp[-length(sp)]
> sp.tomorrow <- sp[-1]
> sp.spline <- smooth.spline(
sp.tomorrow <- sp[-1]
sp.today <- sp[-length(sp)]
sp.spline <- smooth.spline(x=sp.today,y=sp.tomorrow,cv=TRUE)
residuals(sp.spline)
mean(residuals(sp.spline))
mean(residuals(sp.spline). na.rm = T)
mean(residuals(sp.spline), na.rm = T)
mean(residuals(sp.spline), na.rm = T)
residuals(lm(sp.tomorrow ~ sp.today))
mean(residuals(lm(sp.tomorrow ~ sp.today)))
mean(residuals(sp.spline), na.rm = T)
librar(glmnet)
library(glmnet)
install.packages('npreg')
library('npreg')
residuals(ss(y = sp.tomorrow, x = sp.today))
temp <- ss(y = sp.tomorrow, x = sp.today)
mean(temp$data$y - temp$y)
sum(is.na(temp$data$y))
range(is.na(temp$data$y))
range(temp$data$y)
length(unique(temp$data$y))
lassoFit <- glmnet::glmnet(x = sp.today, y = sp.tomorrow, family = "gaussian")
lassoFit <- glmnet::glmnet(x = cbind(sp.today, rnorm(length(sp.tomorrow))), y = sp.tomorrow, family = "gaussian")
mean(residuals(lassoFit))
predict(lassoFit)
?eigen2arma
eigen2arma
library(pcCov)
eigen2arma
cov2cor_cpp
library(pcCov)
pcCov::eigen2arma()
pcCov::eigen2arma
pcCov::arma2eigen
library(pcCov)
?quantile
