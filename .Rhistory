# Asymptotic covariance matrix for partial correlations
correctCov <- partialCov(ts = myTS)
ts = myTS
bw = NULL
p <- ncol(ts)
q <- choose(p, 2)
indMat <- pcCov::royVarhelper(p)
indMate <- pcCov::royVarhelper(p, errors = T)
iMatq <- unique(indMat[, 1:2])
# Selecting optimal bandwidth if unspecified
if(is.null(bw)) {
bw <- ceiling(mean(np::b.star(ts)[, 1]))
}
iMate = indMate
iMatq = iMatq
iMate = iMate
p = ncol(ts)
ncovs = nrow(iMate)
N = nrow(ts)
pcCovs = rep(0, ncovs)
bw2 = (bw + 1)^2
n2bw = ceiling((N - 2*bw)/2)
# Tapering weights
hu2s = pcCov::cosTaper_cpp(seq(-bw, bw))[seq(bw, 2*bw)]
hu2s[1] = 1
# Calculating residuals and tapered sub-matrices
resids = matrix(0, nrow = N, ncol = 2*q)
tapeSubsii = array(0, dim = c(bw2, bw2, 2*q))
tapeSubsij = array(0, dim = c(bw2, bw2, 2*q))
i = 0
j = 0
projMat = matrix(0, nrow = N, ncol = N)
designMat = matrix(0, nrow = N, ncol = p)
for(iter in 1:q) {
designMat = ts
i = iMatq[iter, 1]
j = iMatq[iter, 2]
designMat <- designMat[, -c(i, j)]
projMat = designMat %*% solve(t(designMat) %*% designMat, t(designMat))
resids[, iter*2 - 1] = ts[, i] - projMat %*% ts[, i]
resids[, iter*2] = ts[, j] - projMat %*% ts[, j]
tapeSubsii[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2 - 1], bw, hu2s)
tapeSubsii[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2 - 1], bw, hu2s)
}
ssi = 0
ssj = 0
ssij = 0
rdenomij = 0
ssk = 0
ssm = 0
sskm = 0
rdenomkm = 0
h11ij = matrix(0, nrow = bw2, ncol = bw2)
h22ij = matrix(0, nrow = bw2, ncol = bw2)
h12ij = matrix(0, nrow = bw2, ncol = bw2)
h11km = matrix(0, nrow = bw2, ncol = bw2)
h22km = matrix(0, nrow = bw2, ncol = bw2)
h12km = matrix(0, nrow = bw2, ncol = bw2)
sigEpsik = matrix(0, nrow = bw2, ncol = bw2)
sigEpsim = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjk = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjm = matrix(0, nrow = bw2, ncol = bw2)
cpse1 = matrix(0, nrow = bw2, ncol = bw2)
cpse2 = matrix(0, nrow = bw2, ncol = bw2)
cpse3 = matrix(0, nrow = bw2, ncol = bw2)
cpse4 = matrix(0, nrow = bw2, ncol = bw2)
Vijkm = 0
iter = 1
ssi = tapeSubsii[1, 1, iMate[iter, 1]]*(N-1)
ssj = tapeSubsii[1, 1, iMate[iter, 2]]*(N-1)
ssij = tapeSubsij[1, 1, iMate[iter, 1]]*(N-1)
rdenomij = 1 / sqrt(ssi * ssj)
ssk = tapeSubsii[1, 1, iMate[iter, 3]]*(N-1)
ssm = tapeSubsii[1, 1, iMate[iter, 4]]*(N-1)
sskm = tapeSubsij[1, 1, iMate[iter, 3]]*(N-1)
rdenomkm = 1 / sqrt(ssk * ssm)
# Hessian matrices
h11ij = -2*tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3) * ssj +
3*tapeSubsii[, , iMate[iter, 1]]*(rdenomij^5)*(ssj^2)*ssij -
ssij*(rdenomij^3)*ssj*diag(bw2)
h22ij = -2*tapeSubsij[, , iMate[iter, 2]]*(rdenomij^3) * ssi +
3*tapeSubsii[, , iMate[iter, 2]]*(rdenomij^5)*(ssi^2)*ssij -
ssij*(rdenomij^3)*ssi*diag(bw2)
h12ij = -tapeSubsii[, , iMate[iter, 1]]*(rdenomij^3)*ssj +
tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3)*ssij -
tapeSubsii[, , iMate[iter, 2]]*(rdenomij^3)*ssi + rdenomij*diag(bw2)
h11km = -2*tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3) * ssm +
3*tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^5)*(ssm^2)*sskm -
sskm*(rdenomkm^3)*ssm *diag(bw2)
h22km = -2*tapeSubsij[, , iMate[iter, 4]]*(rdenomkm^3) * ssk +
3*tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^5)*(ssk^2)*sskm -
sskm*(rdenomkm^3)*ssk *diag(bw2)
h12km = -tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^3)*ssm +
tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3)*sskm -
tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^3)*ssk + rdenomkm*diag(bw2)
h12ijNew = 1/sqrt(ssi*ssj) * (diag(bw2) - 1/ssi*tapeSubsii[, , iMate[iter, 1]] - 1/ssj*tapeSubsii[, , iMate[iter, 2]] + ssij/(ssi*ssj) * tapeSubsij[, , iMate[iter, 1]])
h12ijNew-h12ij
h11ijNew = -2*tapeSubsij[, , iMate[iter, 1]]*(ssj / (ssi*ssj)^(3/2)) + 3*tapeSubsii[, , iMate[iter, 1]]*ssi^2*ssij / (ssi*ssj)^(5/2) - daig(bw2)*ssij*ssj / (ssi*ssj)^(3/2)
h11ijNew = -2*tapeSubsij[, , iMate[iter, 1]]*(ssj / (ssi*ssj)^(3/2)) + 3*tapeSubsii[, , iMate[iter, 1]]*ssi^2*ssij / (ssi*ssj)^(5/2) - diag(bw2)*ssij*ssj / (ssi*ssj)^(3/2)
h11ijNew - h11ij
h11ijNew = -2*tapeSubsij[, , iMate[iter, 1]]*(ssj / (ssi*ssj)^(3/2)) + 3*tapeSubsii[, , iMate[iter, 1]]*ssj^2*ssij / (ssi*ssj)^(5/2) - diag(bw2)*ssij*ssj / (ssi*ssj)^(3/2)
h11ijNew - h11ij
h11ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 1]]*ssij/ssi^2 -2/ssi*tapeSubsij[, , iMate[iter, 1]] - ssij/ssi*diag(bw2))
h11ijNew - h11ij
h22ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 2]]*ssij/ssj^2 -
2/ssj*tapeSubsij[, , iMate[iter, 1]] -
ssij/ssj*diag(bw2))
h22ijNew - h22ij
h22ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 2]]*ssij/ssj^2 -
2/ssj*tapeSubsij[, , iMate[iter, 2]] -
ssij/ssj*diag(bw2))
h22ijNew - h22ij
tapeSubsij[, , iMate[iter, 2]] - tapeSubsij[, , iMate[iter, 1]]
(tapeSubsij[, , iMate[iter, 2]] + tapeSubsij[, , iMate[iter, 1]]) / 2
tapeSubsij[, , iMate[iter, 2]]
tapeSubsij[, , iMate[iter, 1]]
library(tidyverse)
library(pcCov)
# R version of asymptotic covariance estimator
partialCov_R <- function(ts, bw, iMatq, iMate, q) {
iMatq = iMatq
iMate = iMate
p = ncol(ts)
ncovs = nrow(iMate)
N = nrow(ts)
pcCovs = rep(0, ncovs)
bw2 = (bw + 1)^2
n2bw = ceiling((N - 2*bw)/2)
# Tapering weights
hu2s = pcCov::cosTaper_cpp(seq(-bw, bw))[seq(bw, 2*bw)]
hu2s[1] = 1
# Calculating residuals and tapered sub-matrices
resids = matrix(0, nrow = N, ncol = 2*q)
tapeSubsii = array(0, dim = c(bw2, bw2, 2*q))
tapeSubsij = array(0, dim = c(bw2, bw2, 2*q))
i = 0
j = 0
projMat = matrix(0, nrow = N, ncol = N)
designMat = matrix(0, nrow = N, ncol = p)
for(iter in 1:q) {
designMat = ts
i = iMatq[iter, 1]
j = iMatq[iter, 2]
designMat <- designMat[, -c(i, j)]
projMat = designMat %*% solve(t(designMat) %*% designMat, t(designMat))
resids[, iter*2 - 1] = ts[, i] - projMat %*% ts[, i]
resids[, iter*2] = ts[, j] - projMat %*% ts[, j]
tapeSubsii[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2 - 1], bw, hu2s)
tapeSubsii[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2 - 1], bw, hu2s)
}
ssi = 0
ssj = 0
ssij = 0
rdenomij = 0
ssk = 0
ssm = 0
sskm = 0
rdenomkm = 0
h11ij = matrix(0, nrow = bw2, ncol = bw2)
h22ij = matrix(0, nrow = bw2, ncol = bw2)
h12ij = matrix(0, nrow = bw2, ncol = bw2)
h11km = matrix(0, nrow = bw2, ncol = bw2)
h22km = matrix(0, nrow = bw2, ncol = bw2)
h12km = matrix(0, nrow = bw2, ncol = bw2)
sigEpsik = matrix(0, nrow = bw2, ncol = bw2)
sigEpsim = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjk = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjm = matrix(0, nrow = bw2, ncol = bw2)
cpse1 = matrix(0, nrow = bw2, ncol = bw2)
cpse2 = matrix(0, nrow = bw2, ncol = bw2)
cpse3 = matrix(0, nrow = bw2, ncol = bw2)
cpse4 = matrix(0, nrow = bw2, ncol = bw2)
Vijkm = 0
for(iter in 1:ncovs) {
# Averaging cross-covariance tapered estimator
avgTaper = (tapeSubsij[, , iMate[iter, 2]] + tapeSubsij[, , iMate[iter, 1]]) / 2
tapeSubsij[, , iMate[iter, 1]] = avgTaper
tapeSubsij[, , iMate[iter, 2]] = avgTaper
ssi = tapeSubsii[1, 1, iMate[iter, 1]]*(N-1)
ssj = tapeSubsii[1, 1, iMate[iter, 2]]*(N-1)
ssij = tapeSubsij[1, 1, iMate[iter, 1]]*(N-1)
rdenomij = 1 / sqrt(ssi * ssj)
ssk = tapeSubsii[1, 1, iMate[iter, 3]]*(N-1)
ssm = tapeSubsii[1, 1, iMate[iter, 4]]*(N-1)
sskm = tapeSubsij[1, 1, iMate[iter, 3]]*(N-1)
rdenomkm = 1 / sqrt(ssk * ssm)
# Hessian matrices
h11ij = -2*tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3) * ssj +
3*tapeSubsii[, , iMate[iter, 1]]*(rdenomij^5)*(ssj^2)*ssij -
ssij*(rdenomij^3)*ssj*diag(bw2)
h22ij = -2*tapeSubsij[, , iMate[iter, 2]]*(rdenomij^3) * ssi +
3*tapeSubsii[, , iMate[iter, 2]]*(rdenomij^5)*(ssi^2)*ssij -
ssij*(rdenomij^3)*ssi*diag(bw2)
h12ij = -tapeSubsii[, , iMate[iter, 1]]*(rdenomij^3)*ssj +
tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3)*ssij -
tapeSubsii[, , iMate[iter, 2]]*(rdenomij^3)*ssi + rdenomij*diag(bw2)
h11ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 1]]*ssij/ssi^2 -
2/ssi*tapeSubsij[, , iMate[iter, 1]] -
ssij/ssi*diag(bw2))
h22ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 2]]*ssij/ssj^2 -
2/ssj*tapeSubsij[, , iMate[iter, 2]] -
ssij/ssj*diag(bw2))
h12ijNew = 1/sqrt(ssi*ssj) * (diag(bw2) - 1/ssi*tapeSubsii[, , iMate[iter, 1]] -
1/ssj*tapeSubsii[, , iMate[iter, 2]] +
ssij/(ssi*ssj) * tapeSubsij[, , iMate[iter, 1]])
h11km = -2*tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3) * ssm +
3*tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^5)*(ssm^2)*sskm -
sskm*(rdenomkm^3)*ssm *diag(bw2)
h22km = -2*tapeSubsij[, , iMate[iter, 4]]*(rdenomkm^3) * ssk +
3*tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^5)*(ssk^2)*sskm -
sskm*(rdenomkm^3)*ssk *diag(bw2)
h12km = -tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^3)*ssm +
tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3)*sskm -
tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^3)*ssk + rdenomkm*diag(bw2)
sigEpsik = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsim = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 4]], bw, hu2s)
sigEpsjk = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsjm = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 4]], bw, hu2s)
cpse1 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsik) + pcCov::eigenMult2(h12ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsik) + pcCov::eigenMult2(h12km, sigEpsim)))
cpse2 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsim) + pcCov::eigenMult2(h12ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsik) + pcCov::eigenMult2(h22km, sigEpsim)))
cpse3 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsik) + pcCov::eigenMult2(h22ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsjk) + pcCov::eigenMult2(h12km, sigEpsjm)))
cpse4 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsim) + pcCov::eigenMult2(h22ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsjk) + pcCov::eigenMult2(h22km, sigEpsjm)))
Vijkm = n2bw*cpse1[bw+1, bw+1] + sum(diag(cpse1[1:bw, 1:bw])) +
n2bw*cpse2[bw+1, bw+1] + sum(diag(cpse2[1:bw, 1:bw])) +
n2bw*cpse3[bw + 1, bw +1] + sum(diag(cpse3[1:bw, 1:bw])) +
n2bw*cpse4[bw + 1, bw + 1] + sum(diag(cpse4[1:bw, 1:bw]))
pcCovs[iter] = Vijkm
}
# Instantiating covariance matrix
pcCovMat = pcCov::upperTriFill_cpp(q, pcCovs)
diag(pcCovMat) = diag(pcCovMat) / 2
return(pcCovMat + t(pcCovMat))
}
myPartialCov <- function(ts, bw = NULL) {
p <- ncol(ts)
q <- choose(p, 2)
indMat <- pcCov::royVarhelper(p)
indMate <- pcCov::royVarhelper(p, errors = T)
iMatq <- unique(indMat[, 1:2])
# Selecting optimal bandwidth if unspecified
if(is.null(bw)) {
bw <- ceiling(mean(np::b.star(ts)[, 1]))
}
return(partialCov_R(ts = ts, bw = bw, iMatq = iMatq, iMate = indMate, q = q))
}
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
myTS <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
# Asymptotic covariance matrix for partial correlations
correctCov <- partialCov(ts = myTS)
rCov <- myPartialCov(ts = myTS)
# Simulating data to see which function is more correct
N <- 500
p <- 10
q <- choose(p, 2)
# Function for simulating estimated covariances
covSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(0, p),
covMat = diag(1, p))
covArray <- array(0, dim = c(q, q, 2))
covArray[, , 1] <- partialCov(ts = myTS)
covArray[, , 2] <- myPartialCov(ts = myTS)
return(covArray)
}
pcSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(0, p),
covMat = diag(1, p))
pcs <- pcCov::corrMat_cpp(myTS)[upper.tri(diag(p))]
return(pcs)
}
# Estimated covariance matrices
covEstRes <- simplify2array(lapply(X = 1:500,
FUN = covSim))
truePcCov <- cov(t(simplify2array(lapply(X = 1:10000,
FUN = pcSim))))
# Truth
truePcCov
# Cpp version
sum(diag(truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum(diag(truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# Cpp version
sum(diag(truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum(diag(truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# Cpp version
sum(truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q))^2)
# R version
sum(truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q))^2)
# Cpp version
sum((truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum((truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# Cpp version
sum(diag(truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum(diag(truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# Cpp version
sum((truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum((truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
library(tidyverse)
library(pcCov)
# R version of asymptotic covariance estimator
partialCov_R <- function(ts, bw, iMatq, iMate, q) {
iMatq = iMatq
iMate = iMate
p = ncol(ts)
ncovs = nrow(iMate)
N = nrow(ts)
pcCovs = rep(0, ncovs)
bw2 = (bw + 1)^2
n2bw = ceiling((N - 2*bw)/2)
# Tapering weights
hu2s = pcCov::cosTaper_cpp(seq(-bw, bw))[seq(bw, 2*bw)]
hu2s[1] = 1
# Calculating residuals and tapered sub-matrices
resids = matrix(0, nrow = N, ncol = 2*q)
tapeSubsii = array(0, dim = c(bw2, bw2, 2*q))
tapeSubsij = array(0, dim = c(bw2, bw2, 2*q))
i = 0
j = 0
projMat = matrix(0, nrow = N, ncol = N)
designMat = matrix(0, nrow = N, ncol = p)
for(iter in 1:q) {
designMat = ts
i = iMatq[iter, 1]
j = iMatq[iter, 2]
designMat <- designMat[, -c(i, j)]
projMat = designMat %*% solve(t(designMat) %*% designMat, t(designMat))
resids[, iter*2 - 1] = ts[, i] - projMat %*% ts[, i]
resids[, iter*2] = ts[, j] - projMat %*% ts[, j]
tapeSubsii[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2 - 1], bw, hu2s)
tapeSubsii[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2 - 1], bw, hu2s)
}
ssi = 0
ssj = 0
ssij = 0
rdenomij = 0
ssk = 0
ssm = 0
sskm = 0
rdenomkm = 0
h11ij = matrix(0, nrow = bw2, ncol = bw2)
h22ij = matrix(0, nrow = bw2, ncol = bw2)
h12ij = matrix(0, nrow = bw2, ncol = bw2)
h11km = matrix(0, nrow = bw2, ncol = bw2)
h22km = matrix(0, nrow = bw2, ncol = bw2)
h12km = matrix(0, nrow = bw2, ncol = bw2)
sigEpsik = matrix(0, nrow = bw2, ncol = bw2)
sigEpsim = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjk = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjm = matrix(0, nrow = bw2, ncol = bw2)
cpse1 = matrix(0, nrow = bw2, ncol = bw2)
cpse2 = matrix(0, nrow = bw2, ncol = bw2)
cpse3 = matrix(0, nrow = bw2, ncol = bw2)
cpse4 = matrix(0, nrow = bw2, ncol = bw2)
Vijkm = 0
for(iter in 1:ncovs) {
# Averaging cross-covariance tapered estimator
avgTaper = (tapeSubsij[, , iMate[iter, 2]] + tapeSubsij[, , iMate[iter, 1]]) / 2
tapeSubsij[, , iMate[iter, 1]] = avgTaper
tapeSubsij[, , iMate[iter, 2]] = avgTaper
ssi = tapeSubsii[1, 1, iMate[iter, 1]]*(N-1)
ssj = tapeSubsii[1, 1, iMate[iter, 2]]*(N-1)
ssij = tapeSubsij[1, 1, iMate[iter, 1]]*(N-1)
rdenomij = 1 / sqrt(ssi * ssj)
ssk = tapeSubsii[1, 1, iMate[iter, 3]]*(N-1)
ssm = tapeSubsii[1, 1, iMate[iter, 4]]*(N-1)
sskm = tapeSubsij[1, 1, iMate[iter, 3]]*(N-1)
rdenomkm = 1 / sqrt(ssk * ssm)
# Hessian matrices
h11ij = -2*tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3) * ssj +
3*tapeSubsii[, , iMate[iter, 1]]*(rdenomij^5)*(ssj^2)*ssij -
ssij*(rdenomij^3)*ssj*diag(bw2)
h22ij = -2*tapeSubsij[, , iMate[iter, 2]]*(rdenomij^3) * ssi +
3*tapeSubsii[, , iMate[iter, 2]]*(rdenomij^5)*(ssi^2)*ssij -
ssij*(rdenomij^3)*ssi*diag(bw2)
h12ij = -tapeSubsii[, , iMate[iter, 1]]*(rdenomij^3)*ssj +
tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3)*ssij -
tapeSubsii[, , iMate[iter, 2]]*(rdenomij^3)*ssi + rdenomij*diag(bw2)
h11ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 1]]*ssij/ssi^2 -
2/ssi*tapeSubsij[, , iMate[iter, 1]] -
ssij/ssi*diag(bw2))
h22ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 2]]*ssij/ssj^2 -
2/ssj*tapeSubsij[, , iMate[iter, 2]] -
ssij/ssj*diag(bw2))
h12ijNew = 1/sqrt(ssi*ssj) * (diag(bw2) - 1/ssi*tapeSubsii[, , iMate[iter, 1]] -
1/ssj*tapeSubsii[, , iMate[iter, 2]] +
ssij/(ssi*ssj) * tapeSubsij[, , iMate[iter, 1]])
h11km = -2*tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3) * ssm +
3*tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^5)*(ssm^2)*sskm -
sskm*(rdenomkm^3)*ssm *diag(bw2)
h22km = -2*tapeSubsij[, , iMate[iter, 4]]*(rdenomkm^3) * ssk +
3*tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^5)*(ssk^2)*sskm -
sskm*(rdenomkm^3)*ssk *diag(bw2)
h12km = -tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^3)*ssm +
tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3)*sskm -
tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^3)*ssk + rdenomkm*diag(bw2)
sigEpsik = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsim = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 4]], bw, hu2s)
sigEpsjk = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsjm = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 4]], bw, hu2s)
cpse1 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsik) + pcCov::eigenMult2(h12ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsik) + pcCov::eigenMult2(h12km, sigEpsim)))
cpse2 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsim) + pcCov::eigenMult2(h12ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsik) + pcCov::eigenMult2(h22km, sigEpsim)))
cpse3 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsik) + pcCov::eigenMult2(h22ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsjk) + pcCov::eigenMult2(h12km, sigEpsjm)))
cpse4 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsim) + pcCov::eigenMult2(h22ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsjk) + pcCov::eigenMult2(h22km, sigEpsjm)))
Vijkm = n2bw*cpse1[bw+1, bw+1] + sum(diag(cpse1[1:bw, 1:bw])) +
n2bw*cpse2[bw+1, bw+1] + sum(diag(cpse2[1:bw, 1:bw])) +
n2bw*cpse3[bw + 1, bw +1] + sum(diag(cpse3[1:bw, 1:bw])) +
n2bw*cpse4[bw + 1, bw + 1] + sum(diag(cpse4[1:bw, 1:bw]))
pcCovs[iter] = Vijkm
}
# Instantiating covariance matrix
pcCovMat = pcCov::upperTriFill_cpp(q, pcCovs)
diag(pcCovMat) = diag(pcCovMat) / 2
return(pcCovMat + t(pcCovMat))
}
myPartialCov <- function(ts, bw = NULL) {
p <- ncol(ts)
q <- choose(p, 2)
indMat <- pcCov::royVarhelper(p)
indMate <- pcCov::royVarhelper(p, errors = T)
iMatq <- unique(indMat[, 1:2])
# Selecting optimal bandwidth if unspecified
if(is.null(bw)) {
bw <- ceiling(mean(np::b.star(ts)[, 1]))
}
return(partialCov_R(ts = ts, bw = bw, iMatq = iMatq, iMate = indMate, q = q))
}
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
myTS <- varSim(nt = 50, coeffMat = diag(0.50, 5), covMat = diag(1, 5))
# Asymptotic covariance matrix for partial correlations
correctCov <- partialCov(ts = myTS)
rCov <- myPartialCov(ts = myTS)
# Simulating data to see which function is more correct
N <- 200
p <- 10
q <- choose(p, 2)
# Function for simulating estimated covariances
covSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(0, p),
covMat = diag(1, p))
covArray <- array(0, dim = c(q, q, 2))
covArray[, , 1] <- partialCov(ts = myTS)
covArray[, , 2] <- myPartialCov(ts = myTS)
return(covArray)
}
pcSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(0, p),
covMat = diag(1, p))
pcs <- pcCov::corrMat_cpp(myTS)[upper.tri(diag(p))]
return(pcs)
}
# Estimated covariance matrices
covEstRes <- simplify2array(lapply(X = 1:500,
FUN = covSim))
truePcCov <- cov(t(simplify2array(lapply(X = 1:10000,
FUN = pcSim))))
# Truth
truePcCov
# Cpp version
sum(diag(truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum(diag(truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# Cpp version
sum((truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum((truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# Cpp version
sum((truePcCov - apply(covEstRes[, , 1, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
# R version
sum((truePcCov - apply(covEstRes[, , 2, ], FUN = mean,
MARGIN = 1:2)*(N / (N-q)))^2)
