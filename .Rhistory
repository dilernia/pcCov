hedgesOlkin <- indCovMat(corrMatrix = corrMat_cpp(myTS, partial = TRUE))
# Truth
truePcCov
# Estimators
hedgesOlkin / N
correctCov * ((N-p)^(-1) * N)^4
library(tidyverse)
library(pcCov)
# R version of asymptotic covariance estimator
partialCov_R <- function(ts, bw, iMatq, iMate, q) {
iMatq = iMatq
iMate = iMate
p = ncol(ts)
ncovs = nrow(iMate)
N = nrow(ts)
pcCovs = rep(0, ncovs)
bw2 = (bw + 1)^2
n2bw = ceiling((N - 2*bw)/2)
# Tapering weights
hu2s = pcCov::cosTaper_cpp(seq(-bw, bw))[seq(bw, 2*bw)]
hu2s[1] = 1
# Calculating residuals and tapered sub-matrices
resids = matrix(0, nrow = N, ncol = 2*q)
tapeSubsii = array(0, dim = c(bw2, bw2, 2*q))
tapeSubsij = array(0, dim = c(bw2, bw2, 2*q))
i = 0
j = 0
projMat = matrix(0, nrow = N, ncol = N)
designMat = matrix(0, nrow = N, ncol = p)
for(iter in 1:q) {
designMat = ts
i = iMatq[iter, 1]
j = iMatq[iter, 2]
designMat <- designMat[, -c(i, j)]
projMat = designMat %*% solve(t(designMat) %*% designMat, t(designMat))
resids[, iter*2 - 1] = ts[, i] - projMat %*% ts[, i]
resids[, iter*2] = ts[, j] - projMat %*% ts[, j]
tapeSubsii[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2 - 1], bw, hu2s)
tapeSubsii[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2 - 1], bw, hu2s)
}
ssi = 0
ssj = 0
ssij = 0
rdenomij = 0
ssk = 0
ssm = 0
sskm = 0
rdenomkm = 0
h11ij = matrix(0, nrow = bw2, ncol = bw2)
h22ij = matrix(0, nrow = bw2, ncol = bw2)
h12ij = matrix(0, nrow = bw2, ncol = bw2)
h11km = matrix(0, nrow = bw2, ncol = bw2)
h22km = matrix(0, nrow = bw2, ncol = bw2)
h12km = matrix(0, nrow = bw2, ncol = bw2)
sigEpsik = matrix(0, nrow = bw2, ncol = bw2)
sigEpsim = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjk = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjm = matrix(0, nrow = bw2, ncol = bw2)
cpse1 = matrix(0, nrow = bw2, ncol = bw2)
cpse2 = matrix(0, nrow = bw2, ncol = bw2)
cpse3 = matrix(0, nrow = bw2, ncol = bw2)
cpse4 = matrix(0, nrow = bw2, ncol = bw2)
Vijkm = 0
for(iter in 1:ncovs) {
# Averaging cross-covariance tapered estimator
# avgTaper = (tapeSubsij[, , iMate[iter, 2]] + tapeSubsij[, , iMate[iter, 1]]) / 2
# tapeSubsij[, , iMate[iter, 1]] = avgTaper
# tapeSubsij[, , iMate[iter, 2]] = avgTaper
ssi = tapeSubsii[1, 1, iMate[iter, 1]]*(N-1)
ssj = tapeSubsii[1, 1, iMate[iter, 2]]*(N-1)
ssij = tapeSubsij[1, 1, iMate[iter, 1]]*(N-1)
rdenomij = 1 / sqrt(ssi * ssj)
ssk = tapeSubsii[1, 1, iMate[iter, 3]]*(N-1)
ssm = tapeSubsii[1, 1, iMate[iter, 4]]*(N-1)
sskm = tapeSubsij[1, 1, iMate[iter, 3]]*(N-1)
rdenomkm = 1 / sqrt(ssk * ssm)
a1 = rdenomij * 3*ssij / ssi^2
a2 = rdenomij * -2 / ssi
a3 = a1 + a2
a4 = rdenomij * -ssij / ssi
a5 = a4
b1 = -rdenomij / ssi
b2 = -rdenomij / ssj
b3 = rdenomij * 2*ssij / (ssi * ssj)
b4 = b1 + b2
b5 = b1 + 0.50*b3
b6 = b2 + 0.5*b3
b7 = rdenomij
b8 = rdenomij
b9 = rdenomij
c1 = rdenomij * 3*ssij / ssj^2
c2 = -rdenomij*2/ssj
c3 = c1 + c2
c4 = -rdenomij * ssij / ssj
c5 = c4
(a1 + b1)*sum(diag(tapeSubsii[, , iMate[iter, 1]])^2) +
(c1 + b2)*sum(diag(tapeSubsii[, , iMate[iter, 2]])^2) +
(a2 + b3 + c2)*sum(diag(tapeSubsij[, , iMate[iter, 1]])^2) +
(a3 + b5)*sum(diag(eigenMult2(tapeSubsii[, , iMate[iter, 1]],
tapeSubsij[, , iMate[iter, 1]]))) +
(b6 + c3)*sum(diag(eigenMult2(tapeSubsii[, , iMate[iter, 2]],
tapeSubsij[, , iMate[iter, 1]]))) +
(b4)*sum(diag(eigenMult2(tapeSubsii[, , iMate[iter, 1]],
tapeSubsii[, , iMate[iter, 2]]))) +
(a4 + b7) * sum(diag(tapeSubsii[, , iMate[iter, 1]])) +
(b8 + c4) * sum(diag(tapeSubsii[, , iMate[iter, 2]])) +
(a5 + b9 + c5) * sum(diag(tapeSubsij[, , iMate[iter, 1]]))
n2bw*cpse1[bw+1, bw+1] + sum(diag(cpse1[1:bw, 1:bw]))
# Hessian matrices
h11ij = -2*tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3) * ssj +
3*tapeSubsii[, , iMate[iter, 1]]*(rdenomij^5)*(ssj^2)*ssij -
ssij*(rdenomij^3)*ssj*diag(bw2)
h22ij = -2*tapeSubsij[, , iMate[iter, 2]]*(rdenomij^3) * ssi +
3*tapeSubsii[, , iMate[iter, 2]]*(rdenomij^5)*(ssi^2)*ssij -
ssij*(rdenomij^3)*ssi*diag(bw2)
h12ij = -tapeSubsii[, , iMate[iter, 1]]*(rdenomij^3)*ssj +
tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3)*ssij -
tapeSubsii[, , iMate[iter, 2]]*(rdenomij^3)*ssi + rdenomij*diag(bw2)
h11ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 1]]*ssij/ssi^2 -
2/ssi*tapeSubsij[, , iMate[iter, 1]] -
ssij/ssi*diag(bw2))
h22ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 2]]*ssij/ssj^2 -
2/ssj*tapeSubsij[, , iMate[iter, 2]] -
ssij/ssj*diag(bw2))
h12ijNew = 1/sqrt(ssi*ssj) * (diag(bw2) - 1/ssi*tapeSubsii[, , iMate[iter, 1]] -
1/ssj*tapeSubsii[, , iMate[iter, 2]] +
ssij/(ssi*ssj) * tapeSubsij[, , iMate[iter, 1]])
h11km = -2*tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3) * ssm +
3*tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^5)*(ssm^2)*sskm -
sskm*(rdenomkm^3)*ssm *diag(bw2)
h22km = -2*tapeSubsij[, , iMate[iter, 4]]*(rdenomkm^3) * ssk +
3*tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^5)*(ssk^2)*sskm -
sskm*(rdenomkm^3)*ssk *diag(bw2)
h12km = -tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^3)*ssm +
tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3)*sskm -
tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^3)*ssk + rdenomkm*diag(bw2)
sigEpsik = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsim = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 4]], bw, hu2s)
sigEpsjk = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsjm = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 4]], bw, hu2s)
cpse1 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsik) + pcCov::eigenMult2(h12ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsik) + pcCov::eigenMult2(h12km, sigEpsim)))
cpse2 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsim) + pcCov::eigenMult2(h12ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsik) + pcCov::eigenMult2(h22km, sigEpsim)))
cpse3 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsik) + pcCov::eigenMult2(h22ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsjk) + pcCov::eigenMult2(h12km, sigEpsjm)))
cpse4 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsim) + pcCov::eigenMult2(h22ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsjk) + pcCov::eigenMult2(h22km, sigEpsjm)))
Vijkm = n2bw*cpse1[bw+1, bw+1] + sum(diag(cpse1[1:bw, 1:bw])) +
n2bw*cpse2[bw+1, bw+1] + sum(diag(cpse2[1:bw, 1:bw])) +
n2bw*cpse3[bw + 1, bw +1] + sum(diag(cpse3[1:bw, 1:bw])) +
n2bw*cpse4[bw + 1, bw + 1] + sum(diag(cpse4[1:bw, 1:bw]))
pcCovs[iter] = Vijkm
}
# Instantiating covariance matrix
pcCovMat = pcCov::upperTriFill_cpp(q, pcCovs)
diag(pcCovMat) = diag(pcCovMat) / 2
return(pcCovMat + t(pcCovMat))
}
myPartialCov <- function(ts, bw = NULL) {
p <- ncol(ts)
q <- choose(p, 2)
indMat <- pcCov::royVarhelper(p)
indMate <- pcCov::royVarhelper(p, errors = T)
iMatq <- unique(indMat[, 1:2])
# Selecting optimal bandwidth if unspecified
if(is.null(bw)) {
bw <- ceiling(mean(np::b.star(ts)[, 1]))
}
return(partialCov_R(ts = ts, bw = bw, iMatq = iMatq, iMate = indMate, q = q))
}
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
numVars <- 5
N <- 200
q <- choose(numVars, 2)
p <- numVars
rho <- 0.60
myTS <- varSim(nt = N, coeffMat = diag(rho, numVars), covMat = diag(1, numVars))
# Asymptotic covariance matrix for partial correlations
correctCov <- partialCov(ts = myTS)
rCov <- myPartialCov(ts = myTS)
# Simulating data to see which function is more correct
# Function for simulating estimated covariances
covSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(rho, numVars),
covMat = diag(1, p))
covArray <- array(0, dim = c(q, q, 2))
covArray[, , 1] <- partialCov(ts = myTS)
covArray[, , 2] <- myPartialCov(ts = myTS)
return(covArray)
}
pcSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(rho, numVars),
covMat = diag(1, p))
pcs <- pcCov::corrMat_cpp(myTS)[upper.tri(diag(p))]
return(pcs)
}
truePcCov <- cov(t(simplify2array(lapply(X = 1:10000,
FUN = pcSim))))
# Asymptotic covariance estimator for covariances of
# marginal correlations for independent observations
indCovMat <- function(corrMatrix) {
p <- ncol(corrMatrix)
iMate <- pcCov::royVarhelper(p, errors = FALSE)
ncovs <- nrow(iMate)
rCovs <- numeric(length = ncovs)
for(iter in 1:ncovs) {
i <- iMate[iter, 1]
j <- iMate[iter, 2]
k <- iMate[iter, 3]
m <- iMate[iter, 4]
rCovs[iter] = 0.50*corrMatrix[i, j]*corrMatrix[k, m]*(
corrMatrix[i, j]^2+corrMatrix[i, m]^2+corrMatrix[j, k]^2+corrMatrix[j, m]^2) +
corrMatrix[i, k]*corrMatrix[j, m] + corrMatrix[i, m]*corrMatrix[j, k] -
(corrMatrix[i, j]*corrMatrix[i, k]*corrMatrix[i, m] +
corrMatrix[j, i]*corrMatrix[j, k]*corrMatrix[j, m] +
corrMatrix[k, i]*corrMatrix[k, j]*corrMatrix[k, m] +
corrMatrix[m, i]*corrMatrix[m, j]*corrMatrix[m, k])
}
pcCovMat = pcCov::upperTriFill_cpp(q, rCovs)
diag(pcCovMat) = diag(pcCovMat) / 2
return(pcCovMat + t(pcCovMat))
}
# Hedges & Olkin's independence covariance estimator
hedgesOlkin <- indCovMat(corrMatrix = corrMat_cpp(myTS, partial = TRUE))
# Truth
truePcCov
# Estimators
hedgesOlkin / N
correctCov * ((N-p)^(-1) * N)^4
library(tidyverse)
library(pcCov)
# R version of asymptotic covariance estimator
partialCov_R <- function(ts, bw, iMatq, iMate, q) {
iMatq = iMatq
iMate = iMate
p = ncol(ts)
ncovs = nrow(iMate)
N = nrow(ts)
pcCovs = rep(0, ncovs)
bw2 = (bw + 1)^2
n2bw = ceiling((N - 2*bw)/2)
# Tapering weights
hu2s = pcCov::cosTaper_cpp(seq(-bw, bw))[seq(bw, 2*bw)]
hu2s[1] = 1
# Calculating residuals and tapered sub-matrices
resids = matrix(0, nrow = N, ncol = 2*q)
tapeSubsii = array(0, dim = c(bw2, bw2, 2*q))
tapeSubsij = array(0, dim = c(bw2, bw2, 2*q))
i = 0
j = 0
projMat = matrix(0, nrow = N, ncol = N)
designMat = matrix(0, nrow = N, ncol = p)
for(iter in 1:q) {
designMat = ts
i = iMatq[iter, 1]
j = iMatq[iter, 2]
designMat <- designMat[, -c(i, j)]
projMat = designMat %*% solve(t(designMat) %*% designMat, t(designMat))
resids[, iter*2 - 1] = ts[, i] - projMat %*% ts[, i]
resids[, iter*2] = ts[, j] - projMat %*% ts[, j]
tapeSubsii[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2 - 1], bw, hu2s)
tapeSubsii[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2 - 1] = taperCovSub_cpp(resids[, iter*2 - 1], resids[, iter*2], bw, hu2s)
tapeSubsij[, , iter*2] = taperCovSub_cpp(resids[, iter*2], resids[, iter*2 - 1], bw, hu2s)
}
ssi = 0
ssj = 0
ssij = 0
rdenomij = 0
ssk = 0
ssm = 0
sskm = 0
rdenomkm = 0
h11ij = matrix(0, nrow = bw2, ncol = bw2)
h22ij = matrix(0, nrow = bw2, ncol = bw2)
h12ij = matrix(0, nrow = bw2, ncol = bw2)
h11km = matrix(0, nrow = bw2, ncol = bw2)
h22km = matrix(0, nrow = bw2, ncol = bw2)
h12km = matrix(0, nrow = bw2, ncol = bw2)
sigEpsik = matrix(0, nrow = bw2, ncol = bw2)
sigEpsim = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjk = matrix(0, nrow = bw2, ncol = bw2)
sigEpsjm = matrix(0, nrow = bw2, ncol = bw2)
cpse1 = matrix(0, nrow = bw2, ncol = bw2)
cpse2 = matrix(0, nrow = bw2, ncol = bw2)
cpse3 = matrix(0, nrow = bw2, ncol = bw2)
cpse4 = matrix(0, nrow = bw2, ncol = bw2)
Vijkm = 0
for(iter in 1:ncovs) {
# Averaging cross-covariance tapered estimator
# avgTaper = (tapeSubsij[, , iMate[iter, 2]] + tapeSubsij[, , iMate[iter, 1]]) / 2
# tapeSubsij[, , iMate[iter, 1]] = avgTaper
# tapeSubsij[, , iMate[iter, 2]] = avgTaper
ssi = tapeSubsii[1, 1, iMate[iter, 1]]*(N-1)
ssj = tapeSubsii[1, 1, iMate[iter, 2]]*(N-1)
ssij = tapeSubsij[1, 1, iMate[iter, 1]]*(N-1)
rdenomij = 1 / sqrt(ssi * ssj)
ssk = tapeSubsii[1, 1, iMate[iter, 3]]*(N-1)
ssm = tapeSubsii[1, 1, iMate[iter, 4]]*(N-1)
sskm = tapeSubsij[1, 1, iMate[iter, 3]]*(N-1)
rdenomkm = 1 / sqrt(ssk * ssm)
a1 = rdenomij * 3*ssij / ssi^2
a2 = rdenomij * -2 / ssi
a3 = a1 + a2
a4 = rdenomij * -ssij / ssi
a5 = a4
b1 = -rdenomij / ssi
b2 = -rdenomij / ssj
b3 = rdenomij * 2*ssij / (ssi * ssj)
b4 = b1 + b2
b5 = b1 + 0.50*b3
b6 = b2 + 0.5*b3
b7 = rdenomij
b8 = rdenomij
b9 = rdenomij
c1 = rdenomij * 3*ssij / ssj^2
c2 = -rdenomij*2/ssj
c3 = c1 + c2
c4 = -rdenomij * ssij / ssj
c5 = c4
(a1 + b1)*sum(diag(tapeSubsii[, , iMate[iter, 1]])^2) +
(c1 + b2)*sum(diag(tapeSubsii[, , iMate[iter, 2]])^2) +
(a2 + b3 + c2)*sum(diag(tapeSubsij[, , iMate[iter, 1]])^2) +
(a3 + b5)*sum(diag(eigenMult2(tapeSubsii[, , iMate[iter, 1]],
tapeSubsij[, , iMate[iter, 1]]))) +
(b6 + c3)*sum(diag(eigenMult2(tapeSubsii[, , iMate[iter, 2]],
tapeSubsij[, , iMate[iter, 1]]))) +
(b4)*sum(diag(eigenMult2(tapeSubsii[, , iMate[iter, 1]],
tapeSubsii[, , iMate[iter, 2]]))) +
(a4 + b7) * sum(diag(tapeSubsii[, , iMate[iter, 1]])) +
(b8 + c4) * sum(diag(tapeSubsii[, , iMate[iter, 2]])) +
(a5 + b9 + c5) * sum(diag(tapeSubsij[, , iMate[iter, 1]]))
n2bw*cpse1[bw+1, bw+1] + sum(diag(cpse1[1:bw, 1:bw]))
# Hessian matrices
h11ij = -2*tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3) * ssj +
3*tapeSubsii[, , iMate[iter, 1]]*(rdenomij^5)*(ssj^2)*ssij -
ssij*(rdenomij^3)*ssj*diag(bw2)
h22ij = -2*tapeSubsij[, , iMate[iter, 2]]*(rdenomij^3) * ssi +
3*tapeSubsii[, , iMate[iter, 2]]*(rdenomij^5)*(ssi^2)*ssij -
ssij*(rdenomij^3)*ssi*diag(bw2)
h12ij = -tapeSubsii[, , iMate[iter, 1]]*(rdenomij^3)*ssj +
tapeSubsij[, , iMate[iter, 1]]*(rdenomij^3)*ssij -
tapeSubsii[, , iMate[iter, 2]]*(rdenomij^3)*ssi + rdenomij*diag(bw2)
h11ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 1]]*ssij/ssi^2 -
2/ssi*tapeSubsij[, , iMate[iter, 1]] -
ssij/ssi*diag(bw2))
h22ijNew = 1/sqrt(ssi*ssj) * (3*tapeSubsii[, , iMate[iter, 2]]*ssij/ssj^2 -
2/ssj*tapeSubsij[, , iMate[iter, 2]] -
ssij/ssj*diag(bw2))
h12ijNew = 1/sqrt(ssi*ssj) * (diag(bw2) - 1/ssi*tapeSubsii[, , iMate[iter, 1]] -
1/ssj*tapeSubsii[, , iMate[iter, 2]] +
ssij/(ssi*ssj) * tapeSubsij[, , iMate[iter, 1]])
h11km = -2*tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3) * ssm +
3*tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^5)*(ssm^2)*sskm -
sskm*(rdenomkm^3)*ssm *diag(bw2)
h22km = -2*tapeSubsij[, , iMate[iter, 4]]*(rdenomkm^3) * ssk +
3*tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^5)*(ssk^2)*sskm -
sskm*(rdenomkm^3)*ssk *diag(bw2)
h12km = -tapeSubsii[, , iMate[iter, 3]]*(rdenomkm^3)*ssm +
tapeSubsij[, , iMate[iter, 3]]*(rdenomkm^3)*sskm -
tapeSubsii[, , iMate[iter, 4]]*(rdenomkm^3)*ssk + rdenomkm*diag(bw2)
sigEpsik = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsim = taperCovSub_cpp(resids[ ,iMate[iter, 1]], resids[ ,iMate[iter, 4]], bw, hu2s)
sigEpsjk = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 3]], bw, hu2s)
sigEpsjm = taperCovSub_cpp(resids[ ,iMate[iter, 2]], resids[ ,iMate[iter, 4]], bw, hu2s)
cpse1 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsik) + pcCov::eigenMult2(h12ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsik) + pcCov::eigenMult2(h12km, sigEpsim)))
cpse2 = pcCov::eigenMult2((pcCov::eigenMult2(h11ij, sigEpsim) + pcCov::eigenMult2(h12ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsik) + pcCov::eigenMult2(h22km, sigEpsim)))
cpse3 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsik) + pcCov::eigenMult2(h22ij, sigEpsjk)),
(pcCov::eigenMult2(h11km, sigEpsjk) + pcCov::eigenMult2(h12km, sigEpsjm)))
cpse4 = pcCov::eigenMult2((pcCov::eigenMult2(h12ij, sigEpsim) + pcCov::eigenMult2(h22ij, sigEpsjm)),
(pcCov::eigenMult2(h12km, sigEpsjk) + pcCov::eigenMult2(h22km, sigEpsjm)))
Vijkm = n2bw*cpse1[bw+1, bw+1] + sum(diag(cpse1[1:bw, 1:bw])) +
n2bw*cpse2[bw+1, bw+1] + sum(diag(cpse2[1:bw, 1:bw])) +
n2bw*cpse3[bw + 1, bw +1] + sum(diag(cpse3[1:bw, 1:bw])) +
n2bw*cpse4[bw + 1, bw + 1] + sum(diag(cpse4[1:bw, 1:bw]))
pcCovs[iter] = Vijkm
}
# Instantiating covariance matrix
pcCovMat = pcCov::upperTriFill_cpp(q, pcCovs)
diag(pcCovMat) = diag(pcCovMat) / 2
return(pcCovMat + t(pcCovMat))
}
myPartialCov <- function(ts, bw = NULL) {
p <- ncol(ts)
q <- choose(p, 2)
indMat <- pcCov::royVarhelper(p)
indMate <- pcCov::royVarhelper(p, errors = T)
iMatq <- unique(indMat[, 1:2])
# Selecting optimal bandwidth if unspecified
if(is.null(bw)) {
bw <- ceiling(mean(np::b.star(ts)[, 1]))
}
return(partialCov_R(ts = ts, bw = bw, iMatq = iMatq, iMate = indMate, q = q))
}
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994)
numVars <- 10
N <- 200
q <- choose(numVars, 2)
p <- numVars
rho <- 0.60
myTS <- varSim(nt = N, coeffMat = diag(rho, numVars), covMat = diag(1, numVars))
# Asymptotic covariance matrix for partial correlations
correctCov <- partialCov(ts = myTS)
# Function for simulating estimated covariances
covSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(rho, numVars),
covMat = diag(1, p))
covArray <- array(0, dim = c(q, q, 2))
covArray[, , 1] <- partialCov(ts = myTS)
covArray[, , 2] <- myPartialCov(ts = myTS)
return(covArray)
}
pcSim <- function(seedVal) {
set.seed(seedVal)
myTS <- varSim(nt = N, coeffMat = diag(rho, numVars),
covMat = diag(1, p))
pcs <- pcCov::corrMat_cpp(myTS)[upper.tri(diag(p))]
return(pcs)
}
truePcCov <- cov(t(simplify2array(lapply(X = 1:10000,
FUN = pcSim))))
# Asymptotic covariance estimator for covariances of
# marginal correlations for independent observations
indCovMat <- function(corrMatrix) {
p <- ncol(corrMatrix)
iMate <- pcCov::royVarhelper(p, errors = FALSE)
ncovs <- nrow(iMate)
rCovs <- numeric(length = ncovs)
for(iter in 1:ncovs) {
i <- iMate[iter, 1]
j <- iMate[iter, 2]
k <- iMate[iter, 3]
m <- iMate[iter, 4]
rCovs[iter] = 0.50*corrMatrix[i, j]*corrMatrix[k, m]*(
corrMatrix[i, j]^2+corrMatrix[i, m]^2+corrMatrix[j, k]^2+corrMatrix[j, m]^2) +
corrMatrix[i, k]*corrMatrix[j, m] + corrMatrix[i, m]*corrMatrix[j, k] -
(corrMatrix[i, j]*corrMatrix[i, k]*corrMatrix[i, m] +
corrMatrix[j, i]*corrMatrix[j, k]*corrMatrix[j, m] +
corrMatrix[k, i]*corrMatrix[k, j]*corrMatrix[k, m] +
corrMatrix[m, i]*corrMatrix[m, j]*corrMatrix[m, k])
}
pcCovMat = pcCov::upperTriFill_cpp(q, rCovs)
diag(pcCovMat) = diag(pcCovMat) / 2
return(pcCovMat + t(pcCovMat))
}
# Hedges & Olkin's independence covariance estimator
hedgesOlkin <- indCovMat(corrMatrix = corrMat_cpp(myTS, partial = TRUE))
# Truth
truePcCov
# Estimators
hedgesOlkin / N
correctCov * ((N-p)^(-1) * N)^4
diag(hedgesOlkin / N)
plot(x = truePcCov, y = diag(hedgesOlkin / N))
plot(x = diag(truePcCov), y = diag(hedgesOlkin / N)); cor(x = diag(truePcCov), y = diag(hedgesOlkin / N))
plot(x = diag(truePcCov), y = diag(correctCov * ((N-p)^(-1) * N)^4)); cor(x = diag(truePcCov), y = diag(correctCov * ((N-p)^(-1) * N)^4))
diag(correctCov * ((N-p)^(-1) * N)^4)
diag(truePcCov)
mean((diag(truePcCov) - diag())^2)
mean((diag(truePcCov) - diag(hedgesOlkin / N))^2)
mean((diag(truePcCov) - diag(correctCov * ((N-p)^(-1) * N)^4))^2)
mean((diag(truePcCov) - diag(correctCov))^2)
mean((truePcCov - hedgesOlkin / N)^2)
mean((truePcCov - correctCov * ((N-p)^(-1) * N)^4)^2)
mean((truePcCov - correctCov)^2)
vals <- 109, 123, 132, 150, 127, 118, 102, 122, 155, 120
vals <- c(109, 123, 132, 150, 127, 118, 102, 122, 155, 120)
summary(vals)
length(vals)
iqr(vals)
IQR(vals)
IQR(vals)
length(vals)
range(vals)
diff(range(vals))
IQR(vals)
length(vals)
diff(range(vals))
IQR(vals)
length(vals)
mean(vals)
sd(vals)
data.frame(IQR = IQR(vals), n = length(vals), xBar = mean(vals), SD = sd(vals), Var = var(vals))
data.frame(IQR = IQR(vals), n = length(vals), xBar = mean(vals), SD = sd(vals), Var = var(vals))
vals
valsB <- c(109, 123, 132, 150, 129, 118, 102, 122, 155, 120)
data.frame(IQR = IQR(valsB), n = length(valsB), xBar = mean(valsB), SD = sd(valsB), Var = var(valsB))
valsB <- c(109, 123, 132, 150, 139, 118, 102, 122, 155, 120)
data.frame(IQR = IQR(valsB), n = length(valsB), xBar = mean(valsB), SD = sd(valsB), Var = var(valsB))
data.frame(IQR = IQR(vals), n = length(vals), xBar = mean(vals), SD = sd(vals), Var = var(vals))
?IQR
?rexp
vals <- rexp(n = 1000)
hist(vals)
hist(log(vals))
nchar("Metric p φ Taylor Bootstrap Fisher Na ̈ıve Taylor Bootstrap Fisher Na ̈ıve")
nchar("Metric  p  φ  Taylor  Bootstrap  Fisher  Na ̈ıve  Taylor  Bootstrap  Fisher  Na ̈ıve")
devtools:::document()
devtools:::document()
devtools:::document()
