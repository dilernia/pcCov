microbenchmark::microbenchmark(partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2)), royVar(ts = myTS))
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994); p <- 5
myTS <- varSim(nt = 50, coeffMat = diag(0.50, p), covMat = diag(1, p))
# Asymptotic covariance matrix for partial correlations
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
# Generate multivariate time series with 5 variables from a
# first-order VAR model with 50 time points
set.seed(1994); p <- 10
myTS <- varSim(nt = 50, coeffMat = diag(0.50, p), covMat = diag(1, p))
# Asymptotic covariance matrix for partial correlations
partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2))
microbenchmark::microbenchmark(partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2)), royVar(ts = myTS), times = 50)
microbenchmark::microbenchmark(partialCov_cpp(myTS, bw = 5, iMatq = unique(royVarhelper(p)[, 1:2]),
iMate = royVarhelper(p, errors = T), q = choose(p, 2)), royVar(ts = myTS, bw = 5), times = 10)
devtools::document()
devtools::document()
devtools::check()
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
library(pcCov)
pcCov::partialCov_cpp()
pcCov::partialCov_cpp
Rcpp::compileAttributes()
library(pcCov)
library(pcCov)
library(pcCov)
Rcpp::compileAttributes()
library(pcCov)
devtools::document()
remove.packages('pcCov')
RcppArmadillo::RcppArmadilloLibs()
RcppArmadillo::RcppArmadilloLibs()
RcppArmadillo::RcppArmadillo.package.skeleton()
?smooth.spline
require(graphics)
plot(dist ~ speed, data = cars, main = "data(cars)  &  smoothing splines")
cars.spl <- with(cars, smooth.spline(speed, dist))
cars.spl
## This example has duplicate points, so avoid cv = TRUE
myFit <- cars.spl$fit
residuals(myFit)
fitted.values(myFit)
predict(myFit)
predict(myFit)$x
predict(myFit)$y - cars$speed
residuals(cars.spl)
mean(residuals(cars.spl))
sp <- read.csv("http://www.stat.cmu.edu/~cshalizi/uADA/12/SPhistory.short.csv")
# We only want closing prices
sp <- sp[,7]
# The data are in reverse chronological order, which is weird for us
sp <- rev(sp)
# And in fact we only want log returns, i.e., difference in logged prices
sp <- diff(log(sp))
sp.spline <- smooth.spline(x=sp.today,y=sp.tomorrow,cv=TRUE)
sp.tomorrow <- sp[-1]
sp.today <- sp[-length(sp)]
> sp.tomorrow <- sp[-1]
> sp.spline <- smooth.spline(
sp.tomorrow <- sp[-1]
sp.today <- sp[-length(sp)]
sp.spline <- smooth.spline(x=sp.today,y=sp.tomorrow,cv=TRUE)
residuals(sp.spline)
mean(residuals(sp.spline))
mean(residuals(sp.spline). na.rm = T)
mean(residuals(sp.spline), na.rm = T)
mean(residuals(sp.spline), na.rm = T)
residuals(lm(sp.tomorrow ~ sp.today))
mean(residuals(lm(sp.tomorrow ~ sp.today)))
mean(residuals(sp.spline), na.rm = T)
librar(glmnet)
library(glmnet)
install.packages('npreg')
library('npreg')
residuals(ss(y = sp.tomorrow, x = sp.today))
temp <- ss(y = sp.tomorrow, x = sp.today)
mean(temp$data$y - temp$y)
sum(is.na(temp$data$y))
range(is.na(temp$data$y))
range(temp$data$y)
length(unique(temp$data$y))
lassoFit <- glmnet::glmnet(x = sp.today, y = sp.tomorrow, family = "gaussian")
lassoFit <- glmnet::glmnet(x = cbind(sp.today, rnorm(length(sp.tomorrow))), y = sp.tomorrow, family = "gaussian")
mean(residuals(lassoFit))
predict(lassoFit)
?eigen2arma
eigen2arma
library(pcCov)
eigen2arma
cov2cor_cpp
library(pcCov)
pcCov::eigen2arma()
pcCov::eigen2arma
pcCov::arma2eigen
library(pcCov)
?quantile
remove.packages('pcCov')
devtools::install_github('dilernia/pcCov')
?pcCov::bootVar
?bootVar
?royVar
devtools::document()
?royVar
devtools::document()
?royVar
devtools::document()
devtools::document()
remove.packages('pcCov')
remove.packages('pcCov')
devtools::document()
?bootVar
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
?help("bayeslm")
help("bayeslm")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
dwish_cpp
dwish_cpp(diag(5), 10, diag(rgamma(5)))
dwish_cpp(diag(5), 10, diag(rgamma(5, shape = 1)))
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(pcCov)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
.Last.error.trace
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::compileAttributes()
compileAttributes()
Rcpp::compileAttributes()
library(pcCov)
library(pcCov)
remove.packages('pcCov')
devtools::install_github('dilernia/pcCov')
?pcCov::royVcm2_cpp
?pcCov::royVcm_cpp
pcCov::royVcm2_cpp
?royVcm2_cpp
?pcCov::royVcm2_cpp
pcCov::royVcm_cpp
pcCov::royVcm2_cpp
devtools::document()
library(pcCov)
?royVcm2_cpp
devtools::document()
?royVcm2_cpp
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(pcCov)
# Number of variables (p), AR correlation parameter (phi),
# length of time series (N), all true partial correlations being 0 or not (allZero)
p <- 5
phi <- 0.80
N <- 200
allZero <- FALSE
# Generating true precision matrix
set.seed(1994)
q <- choose(p, 2)
precMat <- diag(0.50, p)
triInds <- upper.tri(diag(p))
precMat[triInds] <- sample(c(-0.30, 0, 0.30), size = q, replace = T) * (!allZero)
precMat <-  precMat + t(precMat)
# Making sure still positive definite
eVals <- eigen(precMat)$values
if(any(eVals <= 0)) {
precMat <- precMat + diag(abs(min(eVals)) + 0.001, p)
}
# True covariance and correlation matrices
pc0Mat <- invCov2part_cpp(precMat)
colnames(pc0Mat) <- rownames(pc0Mat) <- paste0("V", 1:p)
pc0s <- pc0Mat[triInds]
cvMat <- solve(precMat)
r0Mat <- cov2cor(cvMat)
colnames(r0Mat) <- rownames(r0Mat) <- paste0("V", 1:p)
# Generating data from AR model
myTS <- scale(varSim(nt = N, coeffMat = diag(p)*phi,
covMat = cvMat))
library(ggplot2)
library(ggcorrplot)
library(grid)
library(tidyverse)
# Empirical partial correlations
pcMat <- corrMat_cpp(tsData = myTS, partial = TRUE)
pcEsts <- pcMat[triInds]
colnames(pcMat) <- rownames(pcMat) <- paste0("V", 1:p)
# Creating common plot function
corrPlot <- function(corrMatrix, myTitle) {
ggcorrplot::ggcorrplot(corrMatrix, method = "circle", type = "upper") +
scale_fill_gradient2(high = "#D55E00", low = "#0072B2", mid = "white",
limits=c(-1,1), breaks = seq(-1, 1, by = 0.20)) +
labs(x = "", y = "", fill = "Correlation", title = myTitle) +
theme_bw() + theme(legend.key.height = unit(1.9, "cm"), text = element_text(face = "bold"),
axis.text.y = element_text(size = 8, face = "bold"),
axis.text.x = element_text(size = 8, face = "bold", angle = 45),
plot.title = element_text(size = 15, face = "bold"))
}
# Plot for partial correlations
pcPlot <- corrPlot(pcMat, myTitle = "Empirical Partial Correlations") %>% ggplot2::ggplotGrob()
pc0Plot <- corrPlot(pc0Mat, myTitle = "True Partial Correlations") %>% ggplot2::ggplotGrob()
pc0Plot$heights <- pcPlot$heights
pc0Plot$widths <- pcPlot$widths
grid::grid.draw(cbind(pcPlot, pc0Plot))
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
pcCov <- partialCov(ts = myTS) / (N - p) * N
# Optimal bandwidth
banw <- ceiling(mean(np::b.star(myTS)[, 1]))
# Block-Bootstrap intervals
bootSummary <- bootVar(ts = myTS, banw)
bootCIs <- bootSummary[[2]]
zstar <- qnorm(0.975)
# Taylor confidence intervals
indvCIs <- cbind(pcEsts - zstar * sqrt(diag(pcCov)),
pcEsts + zstar * sqrt(diag(pcCov)))
capRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= indvCIs[j, 1]) && (pc0s[j] <= indvCIs[j, 2])}))
# Block-bootstrap intervals
bootCapRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= bootCIs[j, 1]) && (pc0s[j] <= bootCIs[j, 2])}))
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
pcCov <- partialCov(ts = myTS) / (N - p) * N
# Optimal bandwidth
banw <- ceiling(mean(np::b.star(myTS)[, 1]))
# Block-Bootstrap intervals
bootSummary <- bootVar(ts = myTS, banw)
bootCIs <- bootSummary[[2]]
zstar <- qnorm(0.975)
# Taylor confidence intervals
indvCIs <- cbind(pcEsts - zstar * sqrt(diag(pcCov)),
pcEsts + zstar * sqrt(diag(pcCov)))
capRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= indvCIs[j, 1]) && (pc0s[j] <= indvCIs[j, 2])}))
# Block-bootstrap intervals
bootCapRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= bootCIs[j, 1]) && (pc0s[j] <= bootCIs[j, 2])}))
library(pcCov)
# Number of variables (p), AR correlation parameter (phi),
# length of time series (N), all true partial correlations being 0 or not (allZero)
p <- 8
phi <- 0.50
N <- 200
allZero <- FALSE
# Generating true precision matrix
set.seed(1994)
q <- choose(p, 2)
precMat <- diag(0.50, p)
triInds <- upper.tri(diag(p))
precMat[triInds] <- sample(c(-0.30, 0, 0.30), size = q, replace = T) * (!allZero)
precMat <-  precMat + t(precMat)
# Making sure still positive definite
eVals <- eigen(precMat)$values
if(any(eVals <= 0)) {
precMat <- precMat + diag(abs(min(eVals)) + 0.001, p)
}
# True covariance and correlation matrices
pc0Mat <- invCov2part_cpp(precMat)
colnames(pc0Mat) <- rownames(pc0Mat) <- paste0("V", 1:p)
pc0s <- pc0Mat[triInds]
cvMat <- solve(precMat)
r0Mat <- cov2cor(cvMat)
colnames(r0Mat) <- rownames(r0Mat) <- paste0("V", 1:p)
# Generating data from AR model
myTS <- scale(varSim(nt = N, coeffMat = diag(p)*phi,
covMat = cvMat))
# Plotting generated time series
matplot(myTS, type = 'l', lty = "solid",
main = "Generated Multivariate Time Series",
xlab = "Time", ylab = "Value")
library(ggplot2)
library(ggcorrplot)
library(grid)
library(tidyverse)
# Empirical partial correlations
pcMat <- corrMat_cpp(tsData = myTS, partial = TRUE)
pcEsts <- pcMat[triInds]
colnames(pcMat) <- rownames(pcMat) <- paste0("V", 1:p)
# Creating common plot function
corrPlot <- function(corrMatrix, myTitle) {
ggcorrplot::ggcorrplot(corrMatrix, method = "circle", type = "upper") +
scale_fill_gradient2(high = "#D55E00", low = "#0072B2", mid = "white",
limits=c(-1,1), breaks = seq(-1, 1, by = 0.20)) +
labs(x = "", y = "", fill = "Correlation", title = myTitle) +
theme_bw() + theme(legend.key.height = unit(1.9, "cm"), text = element_text(face = "bold"),
axis.text.y = element_text(size = 8, face = "bold"),
axis.text.x = element_text(size = 8, face = "bold", angle = 45),
plot.title = element_text(size = 15, face = "bold"))
}
# Plot for partial correlations
pcPlot <- corrPlot(pcMat, myTitle = "Empirical Partial Correlations") %>% ggplot2::ggplotGrob()
pc0Plot <- corrPlot(pc0Mat, myTitle = "True Partial Correlations") %>% ggplot2::ggplotGrob()
pc0Plot$heights <- pcPlot$heights
pc0Plot$widths <- pcPlot$widths
grid::grid.draw(cbind(pcPlot, pc0Plot))
choose(28, 2)
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
pcCov <- partialCov(ts = myTS) / (N - p) * N
# Optimal bandwidth
banw <- ceiling(mean(np::b.star(myTS)[, 1]))
# Block-Bootstrap intervals
bootSummary <- bootVar(ts = myTS, banw)
bootCIs <- bootSummary[[2]]
zstar <- qnorm(0.975)
# Taylor confidence intervals
indvCIs <- cbind(pcEsts - zstar * sqrt(diag(pcCov)),
pcEsts + zstar * sqrt(diag(pcCov)))
capRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= indvCIs[j, 1]) && (pc0s[j] <= indvCIs[j, 2])}))
# Block-bootstrap intervals
bootCapRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= bootCIs[j, 1]) && (pc0s[j] <= bootCIs[j, 2])}))
?royVar
?vcm_cpp
?glasso::glasso
?bootVar
?royVar
?royVar
?royVar
knitr::opts_chunk$set(echo = TRUE, fig.align = "center",
message = FALSE, warning = FALSE)
library(ggplot2)
library(ggcorrplot)
library(grid)
library(tidyverse)
library(pcCov)
# Number of variables (p), AR correlation parameter (phi),
# length of time series (N), all true partial correlations being 0 or not (allZero)
p <- 8
phi <- 0.50
N <- 200
allZero <- FALSE
# Generating true precision matrix
set.seed(1994)
q <- choose(p, 2)
precMat <- diag(0.50, p)
triInds <- upper.tri(diag(p))
precMat[triInds] <- sample(c(-0.30, 0, 0.30), size = q, replace = T) * (!allZero)
precMat <-  precMat + t(precMat)
# Making sure still positive definite
eVals <- eigen(precMat)$values
if(any(eVals <= 0)) {
precMat <- precMat + diag(abs(min(eVals)) + 0.001, p)
}
# True covariance and correlation matrices
pc0Mat <- invCov2part_cpp(precMat)
colnames(pc0Mat) <- rownames(pc0Mat) <- paste0("V", 1:p)
pc0s <- pc0Mat[triInds]
cvMat <- solve(precMat)
r0Mat <- cov2cor(cvMat)
colnames(r0Mat) <- rownames(r0Mat) <- paste0("V", 1:p)
# Generating data from AR model
myTS <- scale(varSim(nt = N, coeffMat = diag(p)*phi,
covMat = cvMat))
# Plotting generated time series
matplot(myTS, type = 'l', lty = "solid",
main = "Generated Multivariate Time Series",
xlab = "Time", ylab = "Value")
library(ggplot2)
library(ggcorrplot)
library(grid)
library(tidyverse)
# Empirical partial correlations
pcMat <- corrMat_cpp(tsData = myTS, partial = TRUE)
pcEsts <- pcMat[triInds]
colnames(pcMat) <- rownames(pcMat) <- paste0("V", 1:p)
# Creating common plot function
corrPlot <- function(corrMatrix, myTitle) {
ggcorrplot::ggcorrplot(corrMatrix, method = "circle", type = "upper") +
scale_fill_gradient2(high = "#D55E00", low = "#0072B2", mid = "white",
limits=c(-1,1), breaks = seq(-1, 1, by = 0.20)) +
labs(x = "", y = "", fill = "Correlation", title = myTitle) +
theme_bw() + theme(legend.key.height = unit(1.9, "cm"), text = element_text(face = "bold"),
axis.text.y = element_text(size = 8, face = "bold"),
axis.text.x = element_text(size = 8, face = "bold", angle = 45),
plot.title = element_text(size = 15, face = "bold"))
}
# Plot for partial correlations
pcPlot <- corrPlot(pcMat, myTitle = "Empirical Partial Correlations") %>% ggplot2::ggplotGrob()
pc0Plot <- corrPlot(pc0Mat, myTitle = "True Partial Correlations") %>% ggplot2::ggplotGrob()
pc0Plot$heights <- pcPlot$heights
pc0Plot$widths <- pcPlot$widths
grid::grid.draw(cbind(pcPlot, pc0Plot))
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
pcCov <- partialCov(ts = myTS) / (N - p) * N
# Taylor confidence intervals
zstar <- qnorm(0.975)
indvCIs <- cbind(pcEsts - zstar * sqrt(diag(pcCov)),
pcEsts + zstar * sqrt(diag(pcCov)))
# Capture rate
capRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= indvCIs[j, 1]) && (pc0s[j] <= indvCIs[j, 2])}))
capRate
# Optimal bandwidth
banw <- ceiling(mean(np::b.star(myTS)[, 1]))
# Block-Bootstrap intervals
bootSummary <- bootVar(ts = myTS, banw)
bootCIs <- bootSummary[[2]]
# Block-bootstrap intervals
bootCapRate <- mean(sapply(1:q, FUN = function(j){
(pc0s[j] >= bootCIs[j, 1]) && (pc0s[j] <= bootCIs[j, 2])}))
bootCapRate
# Empirical marginal correlations
rMat <- corrMat_cpp(tsData = myTS, partial = FALSE)
rEsts <- rMat[triInds]
colnames(rMat) <- rownames(rMat) <- paste0("V", 1:p)
# Plot for marginal correlations
rPlot <- corrPlot(rMat, myTitle = "Empirical Marginal Correlations") %>% ggplot2::ggplotGrob()
r0Plot <- corrPlot(r0Mat, myTitle = "True Marginal Correlations") %>% ggplot2::ggplotGrob()
r0Plot$heights <- rPlot$heights
r0Plot$widths <- rPlot$widths
grid::grid.draw(cbind(rPlot, r0Plot))
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
rCov <- royVar(ts = myTS)
# Taylor confidence intervals
zstar <- qnorm(0.975)
rindvCIs <- cbind(pcEsts - zstar * sqrt(diag(rCov)),
pcEsts + zstar * sqrt(diag(rCov)))
# Capture rate
rcapRate <- mean(sapply(1:q, FUN = function(j){
(r0s[j] >= rindvCIs[j, 1]) && (r0s[j] <= rindvCIs[j, 2])}))
r0Mat <- cov2cor(cvMat)
r0s <- r0Mat[triInds]
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
rCov <- royVar(ts = myTS)
# Taylor confidence intervals
zstar <- qnorm(0.975)
rindvCIs <- cbind(pcEsts - zstar * sqrt(diag(rCov)),
pcEsts + zstar * sqrt(diag(rCov)))
# Capture rate
rcapRate <- mean(sapply(1:q, FUN = function(j){
(r0s[j] >= rindvCIs[j, 1]) && (r0s[j] <= rindvCIs[j, 2])}))
rcapRate
rindvCIs
r0s
?royVar
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
rCov <- royVar(ts = myTS, partial = FALSE)
# Taylor confidence intervals
zstar <- qnorm(0.975)
rindvCIs <- cbind(pcEsts - zstar * sqrt(diag(rCov)),
pcEsts + zstar * sqrt(diag(rCov)))
# Capture rate
rcapRate <- mean(sapply(1:q, FUN = function(j){
(r0s[j] >= rindvCIs[j, 1]) && (r0s[j] <= rindvCIs[j, 2])}))
rcapRate
rindvCIs
r0s
# Calculating asymptotic covariance estimator for partial correlations w/
# finite sample correction
rCov <- royVar(ts = myTS, partial = FALSE)
# Taylor confidence intervals
zstar <- qnorm(0.975)
rindvCIs <- cbind(rEsts - zstar * sqrt(diag(rCov)),
rEsts + zstar * sqrt(diag(rCov)))
# Capture rate
rcapRate <- mean(sapply(1:q, FUN = function(j) {
(r0s[j] >= rindvCIs[j, 1]) && (r0s[j] <= rindvCIs[j, 2])}))
rcapRate
choose(10, 2)
?grid::grid.draw
