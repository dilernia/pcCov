# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Adjust matrix to be symmetric
#'
#' @param myMat A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
mkSymm_cpp <- function(myMat) {
    .Call(`_pcCov_mkSymm_cpp`, myMat)
}

#' Calculate inverse of matrix
#'
#' @param myMat A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
inv_cpp <- function(myMat) {
    .Call(`_pcCov_inv_cpp`, myMat)
}

#' Convert Eigen matrix to Arma matrix
#'
#' @param eigen_A A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
eigen2arma <- function(eigen_A) {
    .Call(`_pcCov_eigen2arma`, eigen_A)
}

#' Convert Arma matrix to Eigen matrix
#'
#' @param arma_A A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
arma2eigen <- function(arma_A) {
    .Call(`_pcCov_arma2eigen`, arma_A)
}

#' Multiply two matrices
#'
#' @param A A matrix.
#' @param B A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
eigenMult2 <- function(A, B) {
    .Call(`_pcCov_eigenMult2`, A, B)
}

#' Multiply three matrices
#'
#' @param A A matrix.
#' @param B A matrix.
#' @param C A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
eigenMult3 <- function(A, B, C) {
    .Call(`_pcCov_eigenMult3`, A, B, C)
}

#' Multiply four matrices
#'
#' @param A A matrix.
#' @param B A matrix.
#' @param C A matrix.
#' @param D A matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
eigenMult4 <- function(A, B, C, D) {
    .Call(`_pcCov_eigenMult4`, A, B, C, D)
}

#' Convert inverse-covariance matrix to partial correlation matrix
#'
#' @param icmat An inverse-covariance matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
invCov2part_cpp <- function(icmat) {
    .Call(`_pcCov_invCov2part_cpp`, icmat)
}

#' Convert covariance matrix to correlation matrix
#'
#' @param cmat A covariance matrix.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
cov2corr_cpp <- function(cmat) {
    .Call(`_pcCov_cov2corr_cpp`, cmat)
}

#' Calculate marginal or partial correlation matrix
#'
#' @param tsData An n x p data matrix.
#' @param partial Logical. Whether to calculate partial (TRUE) or marginal (FALSE) correlation matrix
#'
#' @return p x p correlation matrix
#'
#' @author
#' Andrew DiLernia
#'
#' @export
corrMat_cpp <- function(tsData, partial = TRUE) {
    .Call(`_pcCov_corrMat_cpp`, tsData, partial)
}

#' Function for Hann window taper
#'
#' @param u Vector of indices for window
#'
#' @author
#' Andrew DiLernia
#'
#' @export
cosTaper_cpp <- function(u) {
    .Call(`_pcCov_cosTaper_cpp`, u)
}

#' Function for exponential window taper
#'
#' @param u Vector of indices for window
#'
#' @author
#' Andrew DiLernia
#'
#' @export
expTaper_cpp <- function(u) {
    .Call(`_pcCov_expTaper_cpp`, u)
}

#' Calculate cross-covariance of two vectors
#'
#' @param u Vector of indices for window
#' @param ts1 First time series vector
#' @param ts2 Second time series vector
#'
#' @author
#' Andrew DiLernia
#'
#' @export
crossCov_cpp <- function(u, ts1, ts2) {
    .Call(`_pcCov_crossCov_cpp`, u, ts1, ts2)
}

#' Calculate cross-covariance of two vectors
#'
#' @param u Vector of indices for window
#' @param ts1 First time series vector
#' @param ts2 Second time series vector
#'
#' @author
#' Andrew DiLernia
#'
#' @export
crossCov2_cpp <- function(u, ts1, ts2) {
    .Call(`_pcCov_crossCov2_cpp`, u, ts1, ts2)
}

#' Calculate taper for two vectors
#'
#' @param ts1 First time series vector
#' @param ts2 Second time series vector
#' @param banw Bandwidth parameter
#'
#' @author
#' Andrew DiLernia
#'
#' @export
taperCov_cpp <- function(ts1, ts2, banw) {
    .Call(`_pcCov_taperCov_cpp`, ts1, ts2, banw)
}

#' Calculate taper for two vectors
#'
#' @param ts1 First time series vector
#' @param ts2 Second time series vector
#' @param banw Bandwidth parameter
#' @param hu2s Weights from selected taper function
#'
#' @author
#' Andrew DiLernia
#'
#' @export
taperCovSub_cpp <- function(ts1, ts2, banw, hu2s) {
    .Call(`_pcCov_taperCovSub_cpp`, ts1, ts2, banw, hu2s)
}

#' Calculate upper-triangular matrix
#'
#' @param n Number of rows / columns of matrix
#' @param x Values to fill upper-triangle with
#'
#' @author
#' Andrew DiLernia
#'
#' @export
upperTriFill_cpp <- function(n, x) {
    .Call(`_pcCov_upperTriFill_cpp`, n, x)
}

#' @title Taylor Series Estimate of Covariance Matrix for Partial Correlations
#'
#' @description This function calculates a second-order Taylor Series estimate of the covariance matrix for partial correlations of a weakly stationary multivariate time series.
#'
#' @param ts \eqn{nt} x \eqn{p} matrix of observed p-variate time series.
#' @param bw nonnegative bandwidth parameter.
#' @param iMatq matrix of indices for partial correlations equal to unique(royVarhelper(p)[, 1:2]).
#' @param iMate matrix of indices for partial correlations equal to royVarhelper(p, errors = T).
#' @param \eqn{q} number of unique partial correlations equal to choose(\eqn{p}, 2).
#'
#' @return \eqn{q} x \eqn{q} covariance matrix
#'
#' @author
#' Andrew DiLernia
#'
#' @export
partialCov_cpp <- function(ts, bw, iMatq, iMate, q) {
    .Call(`_pcCov_partialCov_cpp`, ts, bw, iMatq, iMate, q)
}

thetaHat_cpp <- function(i, j, l, m, ts, n, hu2s, ccMat) {
    .Call(`_pcCov_thetaHat_cpp`, i, j, l, m, ts, n, hu2s, ccMat)
}

deltaHat_cpp <- function(i, j, l, m, mvts, n, hu2s, ccs, ccMat) {
    .Call(`_pcCov_deltaHat_cpp`, i, j, l, m, mvts, n, hu2s, ccs, ccMat)
}

#' @title Roy Asymptotic Variance
#'
#' @description This function calculates the asymptotic covariance matrix for correlations of a stationary multivariate time series as derived by Roy (1989).
#'
#' @param iMat Matrix of correlation indices
#' @param tsData Matrix of observed n-length p-variate time series
#' @param q Integer equal to the number of unique variables pairs given by choose(p, 2)
#' @param bw Bandwidth parameter
#'
#' @return q x q covariance matrix
#'
#' @references Roy, R. (1989). Asymptotic covariance structure of serial correlations in multivariate time series. Biometrika, 76(4), 824-827.
#'
#' @author
#' Andrew DiLernia
#'
#' @export
royVar_cpp <- function(iMat, tsData, q, bw = 10L) {
    .Call(`_pcCov_royVar_cpp`, iMat, tsData, q, bw)
}

#' @export
royVar2_cpp <- function(iMat, tsData, q) {
    .Call(`_pcCov_royVar2_cpp`, iMat, tsData, q)
}

#' Construct Block-Diagonal Matrix
#'
#' @param array3d An n x p x k 3D array of matrices to make into a single block-diagonal matrix
#'
#' @return kn x kp block-diagonal matrix
#'
#' @author
#' Andrew DiLernia
#'
#' @export
bdiagArray_cpp <- function(array3d) {
    .Call(`_pcCov_bdiagArray_cpp`, array3d)
}

xMaker_cpp <- function(K, q) {
    .Call(`_pcCov_xMaker_cpp`, K, q)
}

#' @export
arrayMean_cpp <- function(array3d) {
    .Call(`_pcCov_arrayMean_cpp`, array3d)
}

#' @export
upperTri_cpp <- function(m, incDiag = FALSE) {
    .Call(`_pcCov_upperTri_cpp`, m, incDiag)
}

thetaUpdate_cpp <- function(eVec, K, q) {
    .Call(`_pcCov_thetaUpdate_cpp`, eVec, K, q)
}

sigPsiInv_cpp <- function(sigmas, sigVal, qK, q, K) {
    .Call(`_pcCov_sigPsiInv_cpp`, sigmas, sigVal, qK, q, K)
}

#' @export
arrayEigen_cpp <- function(array3d) {
    .Call(`_pcCov_arrayEigen_cpp`, array3d)
}

#' @export
eigen_cpp <- function(myMat) {
    .Call(`_pcCov_eigen_cpp`, myMat)
}

sigPsiInvBlks_cpp <- function(eigs, sigVal, q, K) {
    .Call(`_pcCov_sigPsiInvBlks_cpp`, eigs, sigVal, q, K)
}

XtSX_cpp <- function(blocks, q, K) {
    .Call(`_pcCov_XtSX_cpp`, blocks, q, K)
}

#' @title Variance Components Model
#'
#' @description This function implements the a variance components model proposed by Fiecas et al. (2017).
#'
#' @param rs Column vector containing q x K unique marginal or partial correlations.
#' @param sigmas 3D array of K estimated q x q covariance matrices for correlations.
#' @param sigEigs List of K matrices containing eigen decomposition matrices for covariance matrices contained in sigmas.
#' @param delta Threshold for algorithm
#' @param maxIters Maximum number of iterations for algorithm
#' @param sig0 Initial value for sigma parameter
#' @param smallRet Logical value, whether or not to return smaller set of results
#'
#' @return List of length 4 containing beta (q x 1), betaCov (q x q), sigma (qK x qK), and psi (qK x qK) estimates. If smallRet = true, then only returns beta and betaCov.
#'
#' @author
#' Andrew DiLernia
#'
#' @references Fiecas, M., Cribben, I., Bahktiari, R., and Cummine, J. (2017). A variance components model for statistical inference on functional connectivity networks. NeuroImage (Orlando, Fla.), 149, 256-266.
#'
#' @export
vcm_cpp <- function(rs, sigmas, sigEigs, delta = 0.001, maxIters = 100L, sig0 = 0.10, smallRet = FALSE) {
    .Call(`_pcCov_vcm_cpp`, rs, sigmas, sigEigs, delta, maxIters, sig0, smallRet)
}

listRoyVar_cpp <- function(ys, q, iMat) {
    .Call(`_pcCov_listRoyVar_cpp`, ys, q, iMat)
}

arrayRoyVar_cpp <- function(ys, q, iMat) {
    .Call(`_pcCov_arrayRoyVar_cpp`, ys, q, iMat)
}

royTest_cpp2 <- function(y1, y2, iMat, alpha = 0.05, multAdj = "holm-bonferroni", nperm = 100L) {
    .Call(`_pcCov_royTest_cpp2`, y1, y2, iMat, alpha, multAdj, nperm)
}

#' @export
dwish_cpp <- function(X, df, S, log_p = FALSE) {
    .Call(`_pcCov_dwish_cpp`, X, df, S, log_p)
}

#' @export
dwishArray_cpp <- function(Xarray, df, S, log_p = FALSE) {
    .Call(`_pcCov_dwishArray_cpp`, Xarray, df, S, log_p)
}

#' @export
dmvnorm_cpp <- function(x, mu, S, log_p = FALSE) {
    .Call(`_pcCov_dmvnorm_cpp`, x, mu, S, log_p)
}

